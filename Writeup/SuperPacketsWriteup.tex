\documentclass[11pt]{article}
\usepackage{setspace}
\usepackage[letterpaper,top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{arydshln}


\title{Super-Packets High-Availability Cluster Project}
\author{Spencer Berg, William Johnson, Jonathan Rogers}
\date{7 March 2018}

\begin{document}
\maketitle

\thispagestyle{empty}

\begin{doublespace}
\section{How This Works}

\subsection{Header Structure}
\begin{center}
\textbf{SHAC 1.0}
\begin{tabular}{|c|c|c|}
\hline
Field & Length (bytes) & Description \\
\hline
VERSION & 6 & The version of SHAC the packet originated from \\
\hline
NODE\_COUNT & 1 & The number of nodes contained in the packet \\
\hline
 &  & Identifiers for the type of node that sent the packet.\\
FLAGS & 1 & The flags are CLIENT, SERVER, and PEER \\ 
 & & in this order where CLIENT is the LSB \\
\hline
NODES & $13*$NODE\_COUNT& \\
\hdashline
IP & 4 & The IPv4 address of the node \\
\hdashline
TIMESTAMP & 8 & UNIX timestamp which give the last time the sender\\
& & received a packet from the node \\
\hdashline
AVAILABILITY & 1 & The status of the node, defined by the LSB \\
\hline
\end{tabular}
\end{center}

\subsection{Client-Server}

The Client Server works by

\subsection{P2P}



\section{The SHAC Protocol}

\subsection{Pros}
The Small High Availability Cluster (SHAC) Protocol has several positive traits. First off the design itself is light weight meaning it can be used on small devices that are running Java. This means that it is excellent for High Availability Clusters whose purpose might be on the IoT side of networking. Secondly while the design uses an entire byte for simplicity in the flags section, the reality is that those bits can easily be converted to be used for other purposes. Thus the SHAC protocol has the ability to grow as new use cases arise. Thirdly on the P2P side of things, each transmission sends all known packets to all other peers. That means any peer joining the network will be known by all other peers in two transmissions. The first being its initial connection to the network and the second being the peer it connected to informing the rest of the network.

\subsection{Cons} 
No protocol is a panacea and the SHAC Protocol is no different. First in P2P mode every node is connected and sends a list of its peers to every other node. In a small cluster this works well but as the cluster grows this increases the amount of traffic considerably. Working with a large cluster would require a different approach to writing a protocol as scaling would be a more significant issue. Secondly using a static time of 30 seconds has some drawbacks especially with UDP. Namely if a packet is dropped it takes half a minute before anything can be done. An improvement might be either reducing the window of time to 20 seconds, or using a static check in time rather than a random one. 

\section{Team Contributions}

The whole team met to discuss the design of the protocol, then split the task of writing code.
The protocol code was written by William.
The P2P and client classes were were written by Spencer.
The Server class was written by Jonathan.
The group collectively worked out any flaws found in the others' code.

\section{Code}
\end{doublespace}
\begin{tiny}

\begin{lstinputlisting}[language=Java]{../src/SHAC/protocol/NodeType.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/protocol/SHACData.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/protocol/SHACNode.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/protocol/SHACProtocol.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/protocol/SHACProtocolTest.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/client/SHACClient.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/server/SHACServer.java}
\end{lstinputlisting}
\begin{lstinputlisting}[language=Java]{../src/SHAC/peer/SHACPeer.java}
\end{lstinputlisting}

\end{tiny}

\end{document}
